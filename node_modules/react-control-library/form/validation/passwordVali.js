"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __importDefault(require("../../shared/constants"));
var enumerations_1 = require("../../shared/enumerations");
var messages_1 = __importDefault(require("../../shared/messages"));
var formPropsIns_1 = require("../formPropsIns");
function isPasswordValid(data, passwordCriteria) {
    var _a, _b, _c, _d, _e, _f;
    data = data || '';
    var addPassFail = function (key, message) {
        if (message === void 0) { message = null; }
        result.push(new formPropsIns_1.PasswordFailIns(key, data, message));
    };
    var validRange = function (data, start, end) { return data >= start && data <= end; };
    var validSymbols = function (data) {
        var syms = constants_1.default.ascii.symbols;
        return syms.includes(data);
    };
    function validate(toCompare, key, messageFunc, start, end, checkRange) {
        if (checkRange === void 0) { checkRange = true; }
        if (!toCompare)
            return;
        data = data || '';
        var count = 0;
        for (var i = 0; i < data.length; i++) {
            var el = checkRange ? data.charCodeAt(i) : data[i];
            var validFunc = checkRange ? validRange : validSymbols;
            var t = validFunc(el, start, end) ? 1 : 0;
            count += t;
        }
        if (count < toCompare)
            addPassFail(key, messageFunc(toCompare));
    }
    function checkSequence(key, start, end, toCompare, message) {
        var count = 0, nextEl = -1;
        for (var i = 0; i < data.length; i++) {
            var el = data.charCodeAt(i);
            if (count === 0) {
                if (validRange(el, start, end)) {
                    nextEl = el + 1;
                    count++;
                }
                else
                    count = 0;
            }
            else {
                if (el === nextEl) {
                    nextEl++;
                    count++;
                }
                else {
                    nextEl = -1;
                    count = 0;
                }
            }
            if (count > toCompare) {
                addPassFail(key, message);
                break;
            }
        }
    }
    var result = [];
    if (!data) {
        addPassFail('required', data);
        return new formPropsIns_1.DetailIns(null, data, false, 'required', result);
    }
    var pc = passwordCriteria;
    var passMess = messages_1.default.password;
    var ascii = constants_1.default.ascii;
    if (pc.minLength && data.length < pc.minLength)
        addPassFail('minLength', passMess.minLength(pc.minLength));
    if (pc.maxLength && data.length > pc.maxLength)
        addPassFail('maxLength', passMess.maxLength(pc.maxLength));
    validate(pc.capital, 'capital', passMess.capital, ascii.A, ascii.Z);
    validate(pc.numberCount, 'numberCount', passMess.numberCount, ascii.zero, ascii.nine);
    validate(pc.symbols, 'symbols', passMess.symbols, 0, 0, false);
    checkSequence(constants_1.default.attributes.numberSeq, ascii.zero, ascii.nine, (_a = pc.sequence) === null || _a === void 0 ? void 0 : _a.number, passMess.numberSeq((_b = pc.sequence) === null || _b === void 0 ? void 0 : _b.number));
    checkSequence(constants_1.default.attributes.characterSeq, ascii.a, ascii.z, (_c = pc.sequence) === null || _c === void 0 ? void 0 : _c.characters, passMess.characterSeq((_d = pc.sequence) === null || _d === void 0 ? void 0 : _d.characters));
    checkSequence(constants_1.default.attributes.characterSeq, ascii.A, ascii.Z, (_e = pc.sequence) === null || _e === void 0 ? void 0 : _e.characters, passMess.characterSeq((_f = pc.sequence) === null || _f === void 0 ? void 0 : _f.characters));
    var passwordStrength = checkPassStrength(data);
    result.push(new formPropsIns_1.PasswordFailIns('strength', data, '', passwordStrength));
    var errorResult = result.filter(function (n) { return n.attribute !== enumerations_1.ValidationType.strength; });
    return new formPropsIns_1.DetailIns(null, data, !errorResult.length, null, result);
}
function checkPassStrength(password) {
    function scorePassword(password) {
        var score = 0;
        if (!password)
            return score;
        var letters = {};
        for (var i = 0; i < password.length; i++) {
            letters[password[i]] = (letters[password[i]] || 0) + 1;
            score += 5.0 / letters[password[i]];
        }
        var variations = {
            digits: /\d/.test(password),
            lower: /[a-z]/.test(password),
            upper: /[A-Z]/.test(password),
            nonWords: /\W/.test(password),
        };
        var variationCount = 0;
        for (var check in variations) {
            variationCount += (variations[check] === true) ? 1 : 0;
        }
        score += (variationCount - 1) * 10;
        return score;
    }
    var score = scorePassword(password);
    var strength = enumerations_1.PasswordStrength.VeryWeak;
    if (score > 90)
        strength = enumerations_1.PasswordStrength.VeryStrong;
    else if (score > 75)
        strength = enumerations_1.PasswordStrength.Strong;
    else if (score > 60)
        strength = enumerations_1.PasswordStrength.Strong;
    else if (score >= 30)
        strength = enumerations_1.PasswordStrength.Weak;
    return { score: score, strength: strength };
}
var passwordVali = { PasswordStrength: enumerations_1.PasswordStrength, isPasswordValid: isPasswordValid };
exports.default = passwordVali;
//# sourceMappingURL=passwordVali.js.map